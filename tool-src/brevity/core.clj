(ns brevity.core
  (:require [clojure.java.shell :refer [sh]]
            [unusual-audio.clj.models.sql :as sql]
            [unusual-audio.clj.models.user :as user]
            [migratus.core :as migratus]
            [crypto.random :as random]
            [clojure.tools.cli :as cli]
            [stencil.core :as stencil]))

(defn print-error [err]
  (println (str "Error running command: " err)))

(defn execute-command [shell-command]
  (println (str ">>>RUNNING: " shell-command))
  (let [{:keys [exit out err]} (apply sh (clojure.string/split shell-command #" "))]
    (if (= 1 exit)
      (print-error err)
      (do
        (print out)
        (println ">>>Success!")))))

(def default-command #(execute-command "echo Haven't implemented this command yet..."))

(defn generate-scaffolding [name [entity]]
  (let [data {:name name
              :entity entity
              :entity-plural (str entity "s")}
        result (stencil/render-string (slurp "tool-src/templates/entity.clj") data)]
    (spit (str "src/" (:name data) "/clj/models/" (:entity data) ".clj") result)))

(defn generate [name [c & commands]]
  (case c
    "scaffolding" (generate-scaffolding name commands)
    (println "Not a valid command!")))

(def migratus-spec
  {:store :database
   ; The migration dir is relative to /resources, so .sql files will be dropped in resources/private/migrations.
   :migration-dir "private/migrations"
   :db {:connection-uri sql/connection-uri}})

(def running-db-instance (atom nil))

(def pending-exit-messages (atom []))

(defn push-exit-message [& parts]
  (swap! pending-exit-messages conj (apply str parts)))

(defn wait-for-db! []
  (try
    (when-let [pending-embedded-database (sql/init!)]
      (reset! running-db-instance @pending-embedded-database))
    (catch Exception _
      (println "Could not spin up a development database, so we'll attempt to connect to an"
        "already-running instance."))))

(def migration-id-opt
  ["-i" "--id ID" "Migration ID"
   :validate [not-empty]
   :required true
   :parse-fn #(Long/parseLong %)])

(defn user-input [prompt-text]
  (print prompt-text)
  (flush)
  (let [reader (java.io.BufferedReader. *in*)]
    (.readLine reader)))

(defn migrate-outstanding [_]
  (wait-for-db!)
  (migratus/migrate migratus-spec))

(defn migrate-new [{:keys [options arguments]}]
  (let [{:keys [name]} options
        [first-arg & _] arguments
        migration-name (or name first-arg (user-input "Migration name: "))]
    (wait-for-db!)
    (println "Creating up.sql and down.sql for" migration-name "in" (:migration-dir migratus-spec))
    (migratus/create migratus-spec migration-name)))

(defn execute-migratus [subcommand]
  (fn [{:keys [options]}]
    (let [{:keys [id]} options
          migration-id (or id (Long/parseLong (user-input "Migration ID: ")))]
      (wait-for-db!)
      (subcommand migratus-spec migration-id))))

(defn insert-user [{:keys [options]}]
  (let [new-password (random/base64 20)
        {:keys [email full-name admin]} options
        new-user {:email (or email (user-input "Email: "))
                  :password new-password
                  :full-name (or full-name (user-input "Full Name: "))
                  :admin? (boolean admin)}]
    (wait-for-db!)
    (binding [sql/*db* (delay (:db migratus-spec))]
      (user/insert! new-user))
    (push-exit-message "Inserted user with autogenerated password: " new-password)))

(def subcommands
  {"migrate"
   {:opts []
    :command migrate-outstanding}
   "migrate:new"
   {:opts
    [["-n" "--name NAME" "Migration Name"
      :validate [not-empty]]]
    :command migrate-new}
   "migrate:up"
   {:opts [migration-id-opt]
    :command
    (execute-migratus migratus/up)}
   "migrate:down"
   {:opts [migration-id-opt]
    :command
    (execute-migratus migratus/down)}
   "migrate:rollback"
   {:opts []
    :command (fn [_] (wait-for-db!) (migratus/rollback))}
   "user:new"
   {:opts [["-e" "--email EMAIL" "The e-mail of the new user"]
           ["-n" "--full-name NAME" "The full name of the new user"]
           ["-a" "--admin" "Makes the new user an admin"]]
    :command insert-user}})

(defn handle-commands [_ subcommand & args]
  (if-let [{:keys [opts command]} (subcommands subcommand)]
    (let [{:keys [options arguments] :as parsed-opts} (cli/parse-opts args opts :strict true)]
      (command parsed-opts))
    (println "Not a valid command!"))
  (when-let [db-instance @running-db-instance]
    (.close db-instance))
  (doseq [message @pending-exit-messages]
    (println message))
  (shutdown-agents))
